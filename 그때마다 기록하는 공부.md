## List comprehension

1. 표현식 + for 문
  `result = [표현식 for 변수 in 리스트]`
  
2. 표현식 + for문 + 조건문
  `result = [표현식 for 변수 in 리스트 조건문]`

3. 조건문 + for문
  `result = [조건문 for 변수 in 리스트]`
  
4. 중첩 for문
  `result = [조건문 for 변수1 in 리스트1 for 변수2 in 리스트2 ...]`

## join 함수
`'구분자'.join(리스트)` or `.join(리스트)`
이 함수를 이용하면 매개변수로 들어온 ['a','b','c']와 같은 리스트를 'abc'처럼 **문자열로 합쳐서 반환**해줌
example)
```python
word = input() #apple
reverse_word = []
for i in range(1,len(word)+1):
    reverse_word.append(word[-i])
#1
result = ""
for j in range(len(reverse_word)):
    result += reverse_word[j]
print(result) #elppa

#2 .join()함수 사용
result2 = "".join(reverse_word)
print(result2) #elppa
```

### replace()로 특정 문자 삭제하기
```python
word = 'banana'
word = word.replace('a', '') # .replace(삭제하고 싶은 문자, 빈칸(?))
print(word) #bnn
```


# 완전 검색 (Exhaustive Search)
문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법
- 브루트 포스 (Brute-force)라고도 함. 
- 모든 경우의 수를 테스트, 최종 해법 도출
- 일반적으로 경우의 수가 상대적으로 작을 때 유용
- 모든 경우의 수를 생성하고 테스트하기 때문에 수행속도는 느리지만 해답을 찾아내지 못할 확률이 작음
- 주어진 문제를 풀 때  우선 완전 검색으로 접근하여 해답을 도출한 후, 성능 개선을 위해 다른 알고리즘을 사용하고 해답을 확인하는 것이 바람직함

### 1. 순열 (Permutation)
- 서로 다른 n개 중 r개를 택하는 순열 : nPr
- nPr = n*(n-1)*(n-2)* ... *(n-r+1)
- {1,2,3}을 포함하는 모든 순열을 생성하는 함수
```python
#동일한 숫자가 포함되지 않았을 때, 각 자릿수별로 loop를 이용
for i1 in range(1,4):
  for i2 in range(1,4):
    if i2 != i1 : 
      for i3 in range(1,4):
        if i3 != i1 and i3 != i2:
          print(i1,i2,i3)
```

# Greedy Algorithm
탐욕 알고리즘 : 최적 해를 구하는데 사용되는 근시안적인 방법
- 여러 경우 중 하나를 걸정해야 할 때마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식으로 진행하여 최종적인 해답에 도달함.
- 수행과정
  1. 해 선택 : 현재 상태에서 부분 문제의 최적 해를 구한 뒤, 이를 부분 해 집합에 추가
  2. 실행 가능성 검사 : 새로운 부분 해 집합이 실행 가능한지 확인
   ( 문제의 제약 조건을 위반하지 않는지를 검사 )
  3. 해 검사 : 새로운 부분 해 집합이 문제의 해가 되는지를 확인.
      아직 전체 문제의 해가 완성되지 않았다면 해 선택부터 다시 시작
- 탐욕 알고리즘적인 접근은 해답을 찾아내지 못하는 경우도 있으므로 유의해야함.
- 그리디 알고리즘으로 문제의 해법을 찾았을 때는 그 해법이 정당한지 검토해야한다!
  
# 구현
- 까다로운 조건들이 많을수록 조건에 맞춰 구현하는 것이 어려워진다. 이때를 대비해서 무엇을 해야할까?
### 파이썬에서 리스트의 크기
- int 자료형 데이터의 개수(리스트의 길이)에 따른 메모리 사용량
  1. 1,000 : 약 4KB
  2. 1,000,000 : 약 4MB
  3. 10,000,000 : 약 40MB
파이썬은 정수 데이터를 사용할 때 별도의 자료형을 명시해줄 필요 없지만 시스템 내부적으로는 이와 유사한 크기만큼 메모리를 차지


## 컴퓨터 메모리 구조
Text -- Data(정적변수, 전역변수) -- Heap -- Stack
low address -------------------- high address
1. Text 영역
- 코드를 실행하기 위해 저장되어 있는 영역. (코드 영역이라고도 함)
- 프로그램을 실행시키기 위해 구성되는 것들이 저장. 즉, 명령문들(제어문, 함수, 상수 등) 저장

2. Data 영역
- 우리가 작성한 코드에서 전역변수, 정적변수 등이 저장되는 공간.
- 이 변수들의 특징은 보통 메인함수 전에 선언되어 프로그램이 끝날 때까지 메모리에 남아있다는 점!
- 좀 더 구체적으로 말하자면 초기화 된 변수 영역과 초기화되지 않은 변수 영역으로 나뉨
  - 초기화 된 변수 영역(Initialized data segment)
  - 초기화되지 않은 변수 영역(Uninitialized data segment). BSS(Block started by symbol)라고도 함

3. Heap 영역
- 쉽게 말하자면 '사용자에 의해 관리되는 영역'
- 동적으로 할당할 변수들이 여기에 저장된다. 언어마다 조금씩 상이하니 '동적 할당 영역' 이라고 알아두자!
- Heap 영역은 대개 낮은 주소에서 높은 주소로 할당(적재)됨!

4. Stack 영역
- 함수를 호출할 때 지역변수, 매개변수들이 저장되는 공간. 메인함수 안에서의 변수들도 포함.
- 함수가 종료되면 해당 함수에 할당된 변수들을 메모리에서 해제시킴. (한마디로 stack 자료구조의 pop과 같은 기능)
  - Text영역에 있는 함수를 호출함과 동시에 내부에 있는 변수들도 stack영역에 할당하게 되고, 해당 함수가 종료되면 stack 메모리에 있던 함수의 변수들은 모두 pop 됨!
- 함수를 재귀 호출할 때 재귀가 깊어져 Stack Overflowrk 나는 이유는! 재귀를 반복적으로 호출하면서 stack 메모리 영역에 해당 함수의 지역변수, 매개변수들이 계~속 할당되다가 OS에서 할당해준 stack영역의 메모리를 넘어버리면 오류가 발생하기 때문!
- Stack영역은 Heap영역과 반대로 높은 주소에서 낮은 주소로 메모리에 할당됨.

**그런데! 메모리 주소가 무엇일까?**
## 메모리 주소(Memory address)
프로그램을 다운로드 할 때 한번쯤은 본 단어! '32bit 운영체제용', '64bit 운영체제용'
- Window 운영체제에서 x86(32bit), x64(64bit)의 차이점은 **비트의 너비(폭)**
  - 비유하자면 고속도로의 32개의 차선을 더 넓혀 64개의 차선으로 만든 것.
  - 직관적으로 말하자면 데이터 처리 단위
- 32개의 비트는 2^32의 경우의 수를, 64개의 비트는 2^64의 경우의 수를 갖는다.
- 따라서 64bit 운영체제가 데이터 처리 단위가 더 많으므로 CPU 처리도 고속화 되고, 새로운 명령어들도 만들 수 있다는 것.
- 이 bit가 메모리와도 연관이 있다!!
---
- **메모리 한칸은 1byte의 크기**를 갖고 있음.
- 32bit 운영체제는 4byte 길이의 주소를 갖음. 
  - 2^32 = 4,294,967,296 개의 주소를 가리킬 수 있다는 의미이고 이는 1바이트 크기의 메모리가 2^32개 까지 인식이 가능하다는 것
  - 즉, 메모리의 최대 크기는 4,294,967,296 = 4GB.
  - 옛날 32bit 운영체제가 대다수인 시절 메모리를 4GB까지밖에 설치할 수 없는 이유가 이것
- 하지만 64bit는 8byte 길이의 주소를 갖음.
  - 2^64 = 18,446,744,073,709,551,616 개의 주소를 가리킬 수 있다는 의미
  - 즉, 메모리의 최대 크기는 18,446,744,073,709,551,616 = 16EB = 16384TB.
  - 이론적으로는 RAM을 16EB까지 설치할 수 있다. (리눅스에서 8EB까지 지원하는 버전이 있다고는 하지만 메인보드에서도 지원 한계량이..)
---
- 이와같이 엄청난 차이를 볼 수 있다!
- 주소를 2진수로 표현하기에는 너무 길어 보통 편의상 16진수로 표현.
32bit : 0x00000000 ~ 0xFFFFFFFF
64bit : 0x0000000000000000 ~ 0xFFFFFFFFFFFFFFFF
![메모리구조](/Users/castleis/Downloads/메모리구조.png)
- 포인터(pointer)는 메모리 공간 주소를 가리키는 변수, 32bit에서는 포인터의 크기가 4byte라면 **64bit에서는 포인터의 크기가 8byte**.

## 코드와 메모리 영역
- Buffer Overflow
  - buffer는 보통 메모리를 의미!
  1. Stack overflow
    - 재귀함수에서 볼 수 있고
    - 어떤 할당된 공간을 넘어서게 되면 overflow가 발생한다고 하고 그 에러가 stack에서 발생한 경우 stack overflow라고 하는 것.
  2. Heap overflow
    - 힙 영역에서 할당된 영역의 경계선 밖으로 넘어갈 때 발생.
    - 가장 흔히 발생하는 경우는 매우 큰 데이터를 생성하려고 할 때!
    - stack에서는 지역변수들이 스택에 쌓인다면 반대로 heap영역에서는 동적으로 관리되는 데이터들이 일정 공간 이상 차지하게 될 경우 발생.
    - 파이썬은 크게 관계 없는 이야기 같은데 C나 C++의 경우에는 더이상 참조되지 않는 데이터들의 메모리를 알아서 반납해주는 GC(Garbage collector)가 없기 때문에 반드시! 더이상 쓰지 않는 동적 할당 변수들을 해제해주어야 함. 그렇지 않으면 흔히 말하는 메모리 누수(Memory leak)가 발생
